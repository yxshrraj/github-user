import { Job } from 'saucelabs';
import type { Services, Capabilities, Options, Frameworks } from '@wdio/types';
import type { Browser, MultiRemoteBrowser } from 'webdriverio';
import { SauceServiceConfig } from './types';
export default class SauceService implements Services.ServiceInstance {
    private _capabilities;
    private _config;
    private _testCnt;
    private _maxErrorStackLength;
    private _failures;
    private _isServiceEnabled;
    private _isJobNameSet;
    private _options;
    private _api;
    private _browser?;
    private _isRDC?;
    private _suiteTitle?;
    private _cid;
    constructor(options: SauceServiceConfig, _capabilities: Capabilities.RemoteCapability, _config: Options.Testrunner);
    /**
     * gather information about runner
     */
    beforeSession(_: never, __: never, ___: never, cid: string): void;
    before(caps: unknown, specs: string[], browser: Browser<'async'> | MultiRemoteBrowser<'async'>): void;
    beforeSuite(suite: Frameworks.Suite): Promise<void>;
    beforeTest(test: Frameworks.Test): Promise<unknown>;
    afterSuite(suite: Frameworks.Suite): void;
    private _reportErrorLog;
    afterTest(test: Frameworks.Test, context: unknown, results: Frameworks.TestResult): void;
    afterHook(test: never, context: never, results: Frameworks.TestResult): void;
    /**
     * For CucumberJS
     */
    beforeFeature(uri: unknown, feature: {
        name: string;
    }): Promise<unknown>;
    /**
     * Runs before a Cucumber Scenario.
     * @param world world object containing information on pickle and test step
     */
    beforeScenario(world: Frameworks.World): Promise<unknown> | undefined;
    beforeStep(step: Frameworks.PickleStep): Promise<unknown>;
    /**
     * Runs after a Cucumber Scenario.
     * @param world world object containing information on pickle and test step
     * @param result result object containing
     * @param result.passed   true if scenario has passed
     * @param result.error    error stack if scenario failed
     * @param result.duration duration of scenario in milliseconds
     */
    afterScenario(world: Frameworks.World, result: Frameworks.PickleResult): void;
    /**
     * update Sauce Labs job
     */
    after(result: number): Promise<unknown>;
    /**
     * upload files to Sauce Labs platform
     * @param jobId id of the job
     * @returns a promise that is resolved once all files got uploaded
     */
    private _uploadLogs;
    onReload(oldSessionId: string, newSessionId: string): Promise<void> | undefined;
    updateJob(sessionId: string, failures: number, calledOnReload?: boolean, browserName?: string): Promise<void>;
    /**
     * VM message data
     */
    getBody(failures: number, calledOnReload?: boolean, browserName?: string): Partial<Job>;
    /**
     * Update the running Sauce Labs Job with an annotation
     */
    setAnnotation(annotation: string): Promise<unknown>;
    private _setJobName;
}
//# sourceMappingURL=service.d.ts.map